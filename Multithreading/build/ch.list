
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

00200200 <Reset_Handler>:
  200200:	b672      	cpsid	i
  200202:	4826      	ldr	r0, [pc, #152]	; (20029c <endfiniloop+0x6>)
  200204:	f380 8809 	msr	PSP, r0
  200208:	4825      	ldr	r0, [pc, #148]	; (2002a0 <endfiniloop+0xa>)
  20020a:	f64e 5108 	movw	r1, #60680	; 0xed08
  20020e:	f2ce 0100 	movt	r1, #57344	; 0xe000
  200212:	6008      	str	r0, [r1, #0]
  200214:	2002      	movs	r0, #2
  200216:	f380 8814 	msr	CONTROL, r0
  20021a:	f3bf 8f6f 	isb	sy
  20021e:	f000 fe47 	bl	200eb0 <__core_init>
  200222:	f000 fd35 	bl	200c90 <__early_init>
  200226:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
  20022a:	491e      	ldr	r1, [pc, #120]	; (2002a4 <endfiniloop+0xe>)
  20022c:	4a1e      	ldr	r2, [pc, #120]	; (2002a8 <endfiniloop+0x12>)

0020022e <msloop>:
  20022e:	4291      	cmp	r1, r2
  200230:	bf3c      	itt	cc
  200232:	f841 0b04 	strcc.w	r0, [r1], #4
  200236:	e7fa      	bcc.n	20022e <msloop>
  200238:	491c      	ldr	r1, [pc, #112]	; (2002ac <endfiniloop+0x16>)
  20023a:	4a18      	ldr	r2, [pc, #96]	; (20029c <endfiniloop+0x6>)

0020023c <psloop>:
  20023c:	4291      	cmp	r1, r2
  20023e:	bf3c      	itt	cc
  200240:	f841 0b04 	strcc.w	r0, [r1], #4
  200244:	e7fa      	bcc.n	20023c <psloop>
  200246:	491a      	ldr	r1, [pc, #104]	; (2002b0 <endfiniloop+0x1a>)
  200248:	4a1a      	ldr	r2, [pc, #104]	; (2002b4 <endfiniloop+0x1e>)
  20024a:	4b1b      	ldr	r3, [pc, #108]	; (2002b8 <endfiniloop+0x22>)

0020024c <dloop>:
  20024c:	429a      	cmp	r2, r3
  20024e:	bf3e      	ittt	cc
  200250:	f851 0b04 	ldrcc.w	r0, [r1], #4
  200254:	f842 0b04 	strcc.w	r0, [r2], #4
  200258:	e7f8      	bcc.n	20024c <dloop>
  20025a:	2000      	movs	r0, #0
  20025c:	4917      	ldr	r1, [pc, #92]	; (2002bc <endfiniloop+0x26>)
  20025e:	4a18      	ldr	r2, [pc, #96]	; (2002c0 <endfiniloop+0x2a>)

00200260 <bloop>:
  200260:	4291      	cmp	r1, r2
  200262:	bf3c      	itt	cc
  200264:	f841 0b04 	strcc.w	r0, [r1], #4
  200268:	e7fa      	bcc.n	200260 <bloop>
  20026a:	f000 fde1 	bl	200e30 <__init_ram_areas>
  20026e:	f000 fe17 	bl	200ea0 <__late_init>
  200272:	4c14      	ldr	r4, [pc, #80]	; (2002c4 <endfiniloop+0x2e>)
  200274:	4d14      	ldr	r5, [pc, #80]	; (2002c8 <endfiniloop+0x32>)

00200276 <initloop>:
  200276:	42ac      	cmp	r4, r5
  200278:	da03      	bge.n	200282 <endinitloop>
  20027a:	f854 1b04 	ldr.w	r1, [r4], #4
  20027e:	4788      	blx	r1
  200280:	e7f9      	b.n	200276 <initloop>

00200282 <endinitloop>:
  200282:	f000 facd 	bl	200820 <main>
  200286:	4c11      	ldr	r4, [pc, #68]	; (2002cc <endfiniloop+0x36>)
  200288:	4d11      	ldr	r5, [pc, #68]	; (2002d0 <endfiniloop+0x3a>)

0020028a <finiloop>:
  20028a:	42ac      	cmp	r4, r5
  20028c:	da03      	bge.n	200296 <endfiniloop>
  20028e:	f854 1b04 	ldr.w	r1, [r4], #4
  200292:	4788      	blx	r1
  200294:	e7f9      	b.n	20028a <finiloop>

00200296 <endfiniloop>:
  200296:	f000 bdfb 	b.w	200e90 <__default_exit>
  20029a:	0000      	.short	0x0000
  20029c:	20000800 	.word	0x20000800
  2002a0:	00200000 	.word	0x00200000
  2002a4:	20000000 	.word	0x20000000
  2002a8:	20000400 	.word	0x20000400
  2002ac:	20000400 	.word	0x20000400
  2002b0:	08000fd4 	.word	0x08000fd4
  2002b4:	20020000 	.word	0x20020000
  2002b8:	20020000 	.word	0x20020000
  2002bc:	20000800 	.word	0x20000800
  2002c0:	20000d60 	.word	0x20000d60
  2002c4:	00200200 	.word	0x00200200
  2002c8:	00200200 	.word	0x00200200
  2002cc:	00200200 	.word	0x00200200
  2002d0:	00200200 	.word	0x00200200

002002d4 <_port_switch>:
  2002d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  2002d8:	f8c1 d00c 	str.w	sp, [r1, #12]
  2002dc:	f8d0 d00c 	ldr.w	sp, [r0, #12]
  2002e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

002002e4 <_port_thread_start>:
  2002e4:	2300      	movs	r3, #0
  2002e6:	f383 8811 	msr	BASEPRI, r3
  2002ea:	4628      	mov	r0, r5
  2002ec:	47a0      	blx	r4
  2002ee:	2000      	movs	r0, #0
  2002f0:	f000 fd46 	bl	200d80 <chThdExit>

002002f4 <_port_switch_from_isr>:
  2002f4:	f000 fd7c 	bl	200df0 <chSchDoReschedule>

002002f8 <_port_exit_from_isr>:
  2002f8:	df00      	svc	0
  2002fa:	e7fe      	b.n	2002fa <_port_exit_from_isr+0x2>
  2002fc:	0000      	movs	r0, r0
	...

00200300 <chTMStartMeasurementX.constprop.7>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
  200300:	4b01      	ldr	r3, [pc, #4]	; (200308 <chTMStartMeasurementX.constprop.7+0x8>)
  200302:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
  200304:	6083      	str	r3, [r0, #8]
  200306:	4770      	bx	lr
  200308:	e0001000 	.word	0xe0001000
  20030c:	00000000 	.word	0x00000000

00200310 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
  200310:	b470      	push	{r4, r5, r6}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  200312:	2320      	movs	r3, #32
  200314:	f383 8811 	msr	BASEPRI, r3
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  200318:	4e0d      	ldr	r6, [pc, #52]	; (200350 <chCoreAllocAligned+0x40>)
  size = MEM_ALIGN_NEXT(size, align);
  20031a:	1e4a      	subs	r2, r1, #1
  20031c:	424d      	negs	r5, r1
  if (((size_t)endmem - (size_t)p) < size) {
  20031e:	4c0d      	ldr	r4, [pc, #52]	; (200354 <chCoreAllocAligned+0x44>)
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  200320:	6833      	ldr	r3, [r6, #0]
  size = MEM_ALIGN_NEXT(size, align);
  200322:	4402      	add	r2, r0
  if (((size_t)endmem - (size_t)p) < size) {
  200324:	6824      	ldr	r4, [r4, #0]
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  200326:	3b01      	subs	r3, #1
  size = MEM_ALIGN_NEXT(size, align);
  200328:	402a      	ands	r2, r5
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
  20032a:	1858      	adds	r0, r3, r1
  20032c:	4028      	ands	r0, r5
  if (((size_t)endmem - (size_t)p) < size) {
  20032e:	1a23      	subs	r3, r4, r0
  200330:	429a      	cmp	r2, r3
  200332:	d806      	bhi.n	200342 <chCoreAllocAligned+0x32>
  nextmem = p + size;
  200334:	4402      	add	r2, r0
  200336:	2300      	movs	r3, #0
  200338:	6032      	str	r2, [r6, #0]
  20033a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
  20033e:	bc70      	pop	{r4, r5, r6}
  200340:	4770      	bx	lr
    return NULL;
  200342:	2000      	movs	r0, #0
  200344:	2300      	movs	r3, #0
  200346:	f383 8811 	msr	BASEPRI, r3
}
  20034a:	bc70      	pop	{r4, r5, r6}
  20034c:	4770      	bx	lr
  20034e:	bf00      	nop
  200350:	20000984 	.word	0x20000984
  200354:	20000980 	.word	0x20000980
	...

00200360 <_port_irq_epilogue>:
  200360:	2320      	movs	r3, #32
  200362:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
  200366:	4b11      	ldr	r3, [pc, #68]	; (2003ac <_port_irq_epilogue+0x4c>)
  200368:	685b      	ldr	r3, [r3, #4]
  20036a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
  20036e:	d102      	bne.n	200376 <_port_irq_epilogue+0x16>
  200370:	f383 8811 	msr	BASEPRI, r3
  200374:	4770      	bx	lr
void _port_irq_epilogue(void) {
  200376:	b480      	push	{r7}
  200378:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
  20037a:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
  20037e:	f04f 7180 	mov.w	r1, #16777216	; 0x1000000
    ctxp--;
  200382:	f1a3 0220 	sub.w	r2, r3, #32
    ctxp->xpsr = (regarm_t)0x01000000;
  200386:	f843 1c04 	str.w	r1, [r3, #-4]
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
  20038a:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
  20038e:	4a08      	ldr	r2, [pc, #32]	; (2003b0 <_port_irq_epilogue+0x50>)
  200390:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
  200392:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
  200394:	6889      	ldr	r1, [r1, #8]
  200396:	6892      	ldr	r2, [r2, #8]
  200398:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
  20039a:	bf8c      	ite	hi
  20039c:	4a05      	ldrhi	r2, [pc, #20]	; (2003b4 <_port_irq_epilogue+0x54>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
  20039e:	4a06      	ldrls	r2, [pc, #24]	; (2003b8 <_port_irq_epilogue+0x58>)
  2003a0:	f843 2c08 	str.w	r2, [r3, #-8]
    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
  }
  port_unlock_from_isr();
}
  2003a4:	46bd      	mov	sp, r7
  2003a6:	bc80      	pop	{r7}
  2003a8:	4770      	bx	lr
  2003aa:	bf00      	nop
  2003ac:	e000ed00 	.word	0xe000ed00
  2003b0:	20000810 	.word	0x20000810
  2003b4:	002002f5 	.word	0x002002f5
  2003b8:	002002f8 	.word	0x002002f8
  2003bc:	00000000 	.word	0x00000000

002003c0 <VectorA4>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_HANDLER) {
  2003c0:	b508      	push	{r3, lr}
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {

  gptp->tim->SR = 0;
  2003c2:	4b0b      	ldr	r3, [pc, #44]	; (2003f0 <VectorA4+0x30>)
  2003c4:	2100      	movs	r1, #0
  if (gptp->state == GPT_ONESHOT) {
  2003c6:	7818      	ldrb	r0, [r3, #0]
  gptp->tim->SR = 0;
  2003c8:	68da      	ldr	r2, [r3, #12]
  if (gptp->state == GPT_ONESHOT) {
  2003ca:	2804      	cmp	r0, #4
  gptp->tim->SR = 0;
  2003cc:	6111      	str	r1, [r2, #16]
  if (gptp->state == GPT_ONESHOT) {
  2003ce:	d107      	bne.n	2003e0 <VectorA4+0x20>
    gptp->state = GPT_READY;                /* Back in GPT_READY state.     */
  2003d0:	2002      	movs	r0, #2
  2003d2:	7018      	strb	r0, [r3, #0]
  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
  2003d4:	6011      	str	r1, [r2, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
  2003d6:	6111      	str	r1, [r2, #16]
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
  2003d8:	68d1      	ldr	r1, [r2, #12]
  2003da:	f021 01ff 	bic.w	r1, r1, #255	; 0xff
  2003de:	60d1      	str	r1, [r2, #12]
    gpt_lld_stop_timer(gptp);               /* Timer automatically stopped. */
  }
  gptp->config->callback(gptp);
  2003e0:	685b      	ldr	r3, [r3, #4]
  2003e2:	4803      	ldr	r0, [pc, #12]	; (2003f0 <VectorA4+0x30>)
  2003e4:	685b      	ldr	r3, [r3, #4]
  2003e6:	4798      	blx	r3
}
  2003e8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_EPILOGUE();
  2003ec:	f7ff bfb8 	b.w	200360 <_port_irq_epilogue>
  2003f0:	20000800 	.word	0x20000800
	...

00200400 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
  200400:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  200402:	2720      	movs	r7, #32
  200404:	f387 8811 	msr	BASEPRI, r7
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime++;
  200408:	4d12      	ldr	r5, [pc, #72]	; (200454 <SysTick_Handler+0x54>)
  20040a:	8cea      	ldrh	r2, [r5, #38]	; 0x26
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  20040c:	462e      	mov	r6, r5
  ch.vtlist.systime++;
  20040e:	3201      	adds	r2, #1
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  200410:	f856 3f1c 	ldr.w	r3, [r6, #28]!
  ch.vtlist.systime++;
  200414:	b292      	uxth	r2, r2
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  200416:	42b3      	cmp	r3, r6
  ch.vtlist.systime++;
  200418:	84ea      	strh	r2, [r5, #38]	; 0x26
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.next) {
  20041a:	d013      	beq.n	200444 <SysTick_Handler+0x44>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.next->delta;
  20041c:	891c      	ldrh	r4, [r3, #8]
  20041e:	3c01      	subs	r4, #1
  200420:	b2a4      	uxth	r4, r4
  200422:	811c      	strh	r4, [r3, #8]
    while (ch.vtlist.next->delta == (systime_t)0) {
  200424:	b974      	cbnz	r4, 200444 <SysTick_Handler+0x44>
      vtfunc_t fn;

      vtp = ch.vtlist.next;
      fn = vtp->func;
      vtp->func = NULL;
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  200426:	681a      	ldr	r2, [r3, #0]
      fn = vtp->func;
  200428:	68d9      	ldr	r1, [r3, #12]
      vtp->func = NULL;
  20042a:	60dc      	str	r4, [r3, #12]
      vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
  20042c:	6056      	str	r6, [r2, #4]
      ch.vtlist.next = vtp->next;
  20042e:	61ea      	str	r2, [r5, #28]
  200430:	f384 8811 	msr	BASEPRI, r4
      chSysUnlockFromISR();
      fn(vtp->par);
  200434:	6918      	ldr	r0, [r3, #16]
  200436:	4788      	blx	r1
  200438:	f387 8811 	msr	BASEPRI, r7
    while (ch.vtlist.next->delta == (systime_t)0) {
  20043c:	69eb      	ldr	r3, [r5, #28]
  20043e:	891a      	ldrh	r2, [r3, #8]
  200440:	2a00      	cmp	r2, #0
  200442:	d0f0      	beq.n	200426 <SysTick_Handler+0x26>
  200444:	2300      	movs	r3, #0
  200446:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
  20044a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  OSAL_IRQ_EPILOGUE();
  20044e:	f7ff bf87 	b.w	200360 <_port_irq_epilogue>
  200452:	bf00      	nop
  200454:	20000810 	.word	0x20000810
	...

00200460 <SVC_Handler>:
void SVC_Handler(void) {
  200460:	b480      	push	{r7}
  200462:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
  200464:	f3ef 8309 	mrs	r3, PSP
  ctxp++;
  200468:	3320      	adds	r3, #32
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
  20046a:	f383 8809 	msr	PSP, r3
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  20046e:	2300      	movs	r3, #0
  200470:	f383 8811 	msr	BASEPRI, r3
}
  200474:	46bd      	mov	sp, r7
  200476:	bc80      	pop	{r7}
  200478:	4770      	bx	lr
  20047a:	bf00      	nop
  20047c:	0000      	movs	r0, r0
	...

00200480 <chTMStopMeasurementX>:
  200480:	4b0e      	ldr	r3, [pc, #56]	; (2004bc <chTMStopMeasurementX+0x3c>)
  tmp->last = (now - tmp->last) - offset;
  200482:	6882      	ldr	r2, [r0, #8]
  200484:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  200486:	490e      	ldr	r1, [pc, #56]	; (2004c0 <chTMStopMeasurementX+0x40>)
  tmp->last = (now - tmp->last) - offset;
  200488:	1a9b      	subs	r3, r3, r2
  if (tmp->last > tmp->worst) {
  20048a:	6842      	ldr	r2, [r0, #4]
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
  20048c:	b430      	push	{r4, r5}
  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
  20048e:	6f0c      	ldr	r4, [r1, #112]	; 0x70
  tmp->n++;
  200490:	68c1      	ldr	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  200492:	1b1b      	subs	r3, r3, r4
  tmp->n++;
  200494:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  200496:	6083      	str	r3, [r0, #8]
  tmp->n++;
  200498:	60c1      	str	r1, [r0, #12]
  tmp->cumulative += (rttime_t)tmp->last;
  20049a:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  20049e:	18e4      	adds	r4, r4, r3
  2004a0:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
  2004a4:	4293      	cmp	r3, r2
  if (tmp->last < tmp->best) {
  2004a6:	6802      	ldr	r2, [r0, #0]
    tmp->worst = tmp->last;
  2004a8:	bf88      	it	hi
  2004aa:	6043      	strhi	r3, [r0, #4]
  if (tmp->last < tmp->best) {
  2004ac:	4293      	cmp	r3, r2
  tmp->cumulative += (rttime_t)tmp->last;
  2004ae:	e9c0 4504 	strd	r4, r5, [r0, #16]
    tmp->best = tmp->last;
  2004b2:	bf38      	it	cc
  2004b4:	6003      	strcc	r3, [r0, #0]
}
  2004b6:	bc30      	pop	{r4, r5}
  2004b8:	4770      	bx	lr
  2004ba:	bf00      	nop
  2004bc:	e0001000 	.word	0xe0001000
  2004c0:	20000810 	.word	0x20000810
	...

002004d0 <wakeup>:
  2004d0:	2320      	movs	r3, #32
  2004d2:	f383 8811 	msr	BASEPRI, r3
  switch (tp->state) {
  2004d6:	f890 3020 	ldrb.w	r3, [r0, #32]
  2004da:	2b07      	cmp	r3, #7
  2004dc:	d80e      	bhi.n	2004fc <wakeup+0x2c>
  2004de:	e8df f003 	tbb	[pc, r3]
  2004e2:	0d28      	.short	0x0d28
  2004e4:	0408240d 	.word	0x0408240d
  2004e8:	080d      	.short	0x080d
    chSemFastSignalI(tp->u.wtsemp);
  2004ea:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
  2004ec:	6893      	ldr	r3, [r2, #8]
  2004ee:	3301      	adds	r3, #1
  2004f0:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
  2004f2:	e890 000c 	ldmia.w	r0, {r2, r3}
  2004f6:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
  2004f8:	6802      	ldr	r2, [r0, #0]
  2004fa:	6053      	str	r3, [r2, #4]
  tp->state = CH_STATE_READY;
  2004fc:	2200      	movs	r2, #0
  2004fe:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
  200500:	4b0e      	ldr	r3, [pc, #56]	; (20053c <wakeup+0x6c>)
  tp->state = CH_STATE_READY;
  200502:	f880 2020 	strb.w	r2, [r0, #32]
static void wakeup(void *p) {
  200506:	b410      	push	{r4}
  tp->u.rdymsg = MSG_TIMEOUT;
  200508:	f04f 34ff 	mov.w	r4, #4294967295
  20050c:	6244      	str	r4, [r0, #36]	; 0x24
    cp = cp->queue.next;
  20050e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  200510:	689a      	ldr	r2, [r3, #8]
  200512:	428a      	cmp	r2, r1
  200514:	d2fb      	bcs.n	20050e <wakeup+0x3e>
  tp->queue.prev             = cp->queue.prev;
  200516:	685a      	ldr	r2, [r3, #4]
  200518:	2100      	movs	r1, #0
  tp->queue.next             = cp;
  20051a:	6003      	str	r3, [r0, #0]
  tp->queue.prev             = cp->queue.prev;
  20051c:	6042      	str	r2, [r0, #4]
  tp->queue.prev->queue.next = tp;
  20051e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
  200520:	6058      	str	r0, [r3, #4]
  200522:	f381 8811 	msr	BASEPRI, r1
}
  200526:	bc10      	pop	{r4}
  200528:	4770      	bx	lr
    *tp->u.wttrp = NULL;
  20052a:	6a43      	ldr	r3, [r0, #36]	; 0x24
  20052c:	2200      	movs	r2, #0
  20052e:	601a      	str	r2, [r3, #0]
  200530:	e7e4      	b.n	2004fc <wakeup+0x2c>
  200532:	2300      	movs	r3, #0
  200534:	f383 8811 	msr	BASEPRI, r3
  200538:	4770      	bx	lr
  20053a:	bf00      	nop
  20053c:	20000810 	.word	0x20000810

00200540 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
  200540:	e7fe      	b.n	200540 <_idle_thread>
  200542:	bf00      	nop
	...

00200550 <BusFault_Handler>:
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
__attribute__((weak))
void _unhandled_exception(void) {
  200550:	e7fe      	b.n	200550 <BusFault_Handler>
  200552:	bf00      	nop
	...

00200560 <chSchWakeupS.constprop.12>:
  thread_t *otp = currp;
  200560:	4b15      	ldr	r3, [pc, #84]	; (2005b8 <chSchWakeupS.constprop.12+0x58>)
  if (ntp->prio <= otp->prio) {
  200562:	6881      	ldr	r1, [r0, #8]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  200564:	b4f0      	push	{r4, r5, r6, r7}
  ntp->u.rdymsg = msg;
  200566:	2600      	movs	r6, #0
  thread_t *otp = currp;
  200568:	699d      	ldr	r5, [r3, #24]
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  20056a:	4604      	mov	r4, r0
  ntp->u.rdymsg = msg;
  20056c:	6246      	str	r6, [r0, #36]	; 0x24
  if (ntp->prio <= otp->prio) {
  20056e:	68a8      	ldr	r0, [r5, #8]
  200570:	4281      	cmp	r1, r0
  200572:	d80c      	bhi.n	20058e <chSchWakeupS.constprop.12+0x2e>
  tp->state = CH_STATE_READY;
  200574:	f884 6020 	strb.w	r6, [r4, #32]
    cp = cp->queue.next;
  200578:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  20057a:	689a      	ldr	r2, [r3, #8]
  20057c:	4291      	cmp	r1, r2
  20057e:	d9fb      	bls.n	200578 <chSchWakeupS.constprop.12+0x18>
  tp->queue.prev             = cp->queue.prev;
  200580:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
  200582:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  200584:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  200586:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  200588:	605c      	str	r4, [r3, #4]
}
  20058a:	bcf0      	pop	{r4, r5, r6, r7}
  20058c:	4770      	bx	lr
  cp = (thread_t *)&ch.rlist.queue;
  20058e:	461a      	mov	r2, r3
  tp->state = CH_STATE_READY;
  200590:	f885 6020 	strb.w	r6, [r5, #32]
    cp = cp->queue.next;
  200594:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
  200596:	6891      	ldr	r1, [r2, #8]
  200598:	4288      	cmp	r0, r1
  20059a:	d9fb      	bls.n	200594 <chSchWakeupS.constprop.12+0x34>
  tp->queue.prev             = cp->queue.prev;
  20059c:	6856      	ldr	r6, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
  20059e:	2701      	movs	r7, #1
  tp->queue.next             = cp;
  2005a0:	602a      	str	r2, [r5, #0]
    chSysSwitch(ntp, otp);
  2005a2:	4629      	mov	r1, r5
  tp->queue.prev             = cp->queue.prev;
  2005a4:	606e      	str	r6, [r5, #4]
    chSysSwitch(ntp, otp);
  2005a6:	4620      	mov	r0, r4
  tp->queue.prev->queue.next = tp;
  2005a8:	6035      	str	r5, [r6, #0]
  cp->queue.prev             = tp;
  2005aa:	6055      	str	r5, [r2, #4]
    ntp->state = CH_STATE_CURRENT;
  2005ac:	f884 7020 	strb.w	r7, [r4, #32]
    currp = ntp;
  2005b0:	619c      	str	r4, [r3, #24]
}
  2005b2:	bcf0      	pop	{r4, r5, r6, r7}
    chSysSwitch(ntp, otp);
  2005b4:	f7ff be8e 	b.w	2002d4 <_port_switch>
  2005b8:	20000810 	.word	0x20000810
  2005bc:	00000000 	.word	0x00000000

002005c0 <chThdCreateStatic.constprop.4>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
  2005c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  2005c4:	4603      	mov	r3, r0
  2005c6:	2020      	movs	r0, #32
  2005c8:	f380 8811 	msr	BASEPRI, r0
  REG_INSERT(tp);
  2005cc:	4e1f      	ldr	r6, [pc, #124]	; (20064c <chThdCreateStatic.constprop.4+0x8c>)
  tp->refs      = (trefs_t)1;
  2005ce:	f04f 0e01 	mov.w	lr, #1
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
  2005d2:	f503 7580 	add.w	r5, r3, #256	; 0x100
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  2005d6:	2400      	movs	r4, #0
  2005d8:	f8c3 20dc 	str.w	r2, [r3, #220]	; 0xdc
  2005dc:	f103 08dc 	add.w	r8, r3, #220	; 0xdc
  tp->prio      = prio;
  2005e0:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
  queue_init(&tp->msgqueue);
  2005e4:	f503 7296 	add.w	r2, r3, #300	; 0x12c
  tp->realprio  = prio;
  2005e8:	f8c3 113c 	str.w	r1, [r3, #316]	; 0x13c
  list_init(&tp->waiting);
  2005ec:	f503 7794 	add.w	r7, r3, #296	; 0x128
  REG_INSERT(tp);
  2005f0:	6971      	ldr	r1, [r6, #20]
  tp->state     = CH_STATE_WTSTART;
  2005f2:	2002      	movs	r0, #2
  tp->refs      = (trefs_t)1;
  2005f4:	f883 e122 	strb.w	lr, [r3, #290]	; 0x122
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  2005f8:	f8df c054 	ldr.w	ip, [pc, #84]	; 200650 <chThdCreateStatic.constprop.4+0x90>
  tp->name      = name;
  2005fc:	f8df e054 	ldr.w	lr, [pc, #84]	; 200654 <chThdCreateStatic.constprop.4+0x94>
  tp->state     = CH_STATE_WTSTART;
  200600:	f883 0120 	strb.w	r0, [r3, #288]	; 0x120

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
  200604:	4628      	mov	r0, r5
  tp->wabase = (stkalign_t *)wsp;
  200606:	f8c3 311c 	str.w	r3, [r3, #284]	; 0x11c
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  20060a:	f8c3 810c 	str.w	r8, [r3, #268]	; 0x10c
  20060e:	f8c3 c0fc 	str.w	ip, [r3, #252]	; 0xfc
  tp->name      = name;
  200612:	f8c3 e118 	str.w	lr, [r3, #280]	; 0x118
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
  200616:	f8c3 40e0 	str.w	r4, [r3, #224]	; 0xe0
  tp->flags     = CH_FLAG_MODE_STATIC;
  20061a:	f883 4121 	strb.w	r4, [r3, #289]	; 0x121
  tp->mtxlist   = NULL;
  20061e:	f8c3 4138 	str.w	r4, [r3, #312]	; 0x138
  tp->epending  = (eventmask_t)0;
  200622:	f8c3 4134 	str.w	r4, [r3, #308]	; 0x134
  REG_INSERT(tp);
  200626:	f8c3 6110 	str.w	r6, [r3, #272]	; 0x110
  20062a:	f8c3 1114 	str.w	r1, [r3, #276]	; 0x114
  20062e:	610d      	str	r5, [r1, #16]
  tlp->next = (thread_t *)tlp;
  200630:	f8c3 7128 	str.w	r7, [r3, #296]	; 0x128
  tqp->next = (thread_t *)tqp;
  200634:	f8c3 212c 	str.w	r2, [r3, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
  200638:	f8c3 2130 	str.w	r2, [r3, #304]	; 0x130
  20063c:	6175      	str	r5, [r6, #20]
  chSchWakeupS(tp, MSG_OK);
  20063e:	f7ff ff8f 	bl	200560 <chSchWakeupS.constprop.12>
  200642:	f384 8811 	msr	BASEPRI, r4
  chSysUnlock();

  return tp;
}
  200646:	4628      	mov	r0, r5
  200648:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  20064c:	20000810 	.word	0x20000810
  200650:	002002e5 	.word	0x002002e5
  200654:	08000f2c 	.word	0x08000f2c
	...

00200660 <chSchGoSleepS>:
  thread_t *otp = currp;
  200660:	4b08      	ldr	r3, [pc, #32]	; (200684 <chSchGoSleepS+0x24>)
  thread_t *tp = tqp->next;
  200662:	681a      	ldr	r2, [r3, #0]
  200664:	6999      	ldr	r1, [r3, #24]
void chSchGoSleepS(tstate_t newstate) {
  200666:	b430      	push	{r4, r5}
  otp->state = newstate;
  200668:	f881 0020 	strb.w	r0, [r1, #32]
  currp->state = CH_STATE_CURRENT;
  20066c:	2501      	movs	r5, #1
  tqp->next             = tp->queue.next;
  20066e:	6814      	ldr	r4, [r2, #0]
  chSysSwitch(currp, otp);
  200670:	4610      	mov	r0, r2
  tqp->next->queue.prev = (thread_t *)tqp;
  200672:	6063      	str	r3, [r4, #4]
  tqp->next             = tp->queue.next;
  200674:	601c      	str	r4, [r3, #0]
  currp->state = CH_STATE_CURRENT;
  200676:	f882 5020 	strb.w	r5, [r2, #32]
  currp = queue_fifo_remove(&ch.rlist.queue);
  20067a:	619a      	str	r2, [r3, #24]
}
  20067c:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
  20067e:	f7ff be29 	b.w	2002d4 <_port_switch>
  200682:	bf00      	nop
  200684:	20000810 	.word	0x20000810
	...

00200690 <chSchGoSleepTimeoutS.constprop.5>:
  if (TIME_INFINITE != time) {
  200690:	f64f 72ff 	movw	r2, #65535	; 0xffff
  200694:	4290      	cmp	r0, r2
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
  200696:	b570      	push	{r4, r5, r6, lr}
  200698:	b086      	sub	sp, #24
  if (TIME_INFINITE != time) {
  20069a:	d031      	beq.n	200700 <chSchGoSleepTimeoutS.constprop.5+0x70>
    chVTDoSetI(&vt, time, wakeup, currp);
  20069c:	4c1c      	ldr	r4, [pc, #112]	; (200710 <chSchGoSleepTimeoutS.constprop.5+0x80>)
  20069e:	4603      	mov	r3, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
  2006a0:	481c      	ldr	r0, [pc, #112]	; (200714 <chSchGoSleepTimeoutS.constprop.5+0x84>)
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.next;
  2006a2:	69e2      	ldr	r2, [r4, #28]
  vtp->par = par;
  2006a4:	69a5      	ldr	r5, [r4, #24]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
  2006a6:	8911      	ldrh	r1, [r2, #8]
  vtp->par = par;
  2006a8:	9505      	str	r5, [sp, #20]
  while (p->delta < delta) {
  2006aa:	428b      	cmp	r3, r1
  vtp->func = vtfunc;
  2006ac:	9004      	str	r0, [sp, #16]
  while (p->delta < delta) {
  2006ae:	d905      	bls.n	2006bc <chSchGoSleepTimeoutS.constprop.5+0x2c>
    delta -= p->delta;
  2006b0:	1a5b      	subs	r3, r3, r1
    p = p->next;
  2006b2:	6812      	ldr	r2, [r2, #0]
    delta -= p->delta;
  2006b4:	b29b      	uxth	r3, r3
  while (p->delta < delta) {
  2006b6:	8911      	ldrh	r1, [r2, #8]
  2006b8:	4299      	cmp	r1, r3
  2006ba:	d3f9      	bcc.n	2006b0 <chSchGoSleepTimeoutS.constprop.5+0x20>
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
  2006bc:	6855      	ldr	r5, [r2, #4]
  vtp->prev->next = vtp;
  2006be:	a901      	add	r1, sp, #4
  vtp->next = p;
  2006c0:	9201      	str	r2, [sp, #4]
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
  ch.vtlist.delta = (systime_t)-1;
  2006c2:	f64f 76ff 	movw	r6, #65535	; 0xffff
  vtp->prev = vtp->next->prev;
  2006c6:	9502      	str	r5, [sp, #8]
    chSchGoSleepS(newstate);
  2006c8:	2008      	movs	r0, #8
  vtp->prev->next = vtp;
  2006ca:	6029      	str	r1, [r5, #0]
  p->prev = vtp;
  2006cc:	6051      	str	r1, [r2, #4]
  vtp->delta = delta
  2006ce:	f8ad 300c 	strh.w	r3, [sp, #12]
  p->delta -= delta;
  2006d2:	8911      	ldrh	r1, [r2, #8]
  2006d4:	1acb      	subs	r3, r1, r3
  2006d6:	8113      	strh	r3, [r2, #8]
  ch.vtlist.delta = (systime_t)-1;
  2006d8:	84a6      	strh	r6, [r4, #36]	; 0x24
  2006da:	f7ff ffc1 	bl	200660 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
  2006de:	9b04      	ldr	r3, [sp, #16]
  2006e0:	b153      	cbz	r3, 2006f8 <chSchGoSleepTimeoutS.constprop.5+0x68>
  chDbgAssert(vtp->func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->next->delta += vtp->delta;
  2006e2:	9b01      	ldr	r3, [sp, #4]
  2006e4:	f8bd 000c 	ldrh.w	r0, [sp, #12]
  2006e8:	891a      	ldrh	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->prev->next = vtp->next;
  2006ea:	9902      	ldr	r1, [sp, #8]
  vtp->next->delta += vtp->delta;
  2006ec:	4402      	add	r2, r0
  2006ee:	811a      	strh	r2, [r3, #8]
  vtp->prev->next = vtp->next;
  2006f0:	600b      	str	r3, [r1, #0]
  vtp->next->prev = vtp->prev;
  2006f2:	9b01      	ldr	r3, [sp, #4]
  2006f4:	6059      	str	r1, [r3, #4]
  vtp->func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.delta = (systime_t)-1;
  2006f6:	84a6      	strh	r6, [r4, #36]	; 0x24
  return currp->u.rdymsg;
  2006f8:	69a3      	ldr	r3, [r4, #24]
}
  2006fa:	6a58      	ldr	r0, [r3, #36]	; 0x24
  2006fc:	b006      	add	sp, #24
  2006fe:	bd70      	pop	{r4, r5, r6, pc}
  200700:	4c03      	ldr	r4, [pc, #12]	; (200710 <chSchGoSleepTimeoutS.constprop.5+0x80>)
    chSchGoSleepS(newstate);
  200702:	2008      	movs	r0, #8
  200704:	f7ff ffac 	bl	200660 <chSchGoSleepS>
  return currp->u.rdymsg;
  200708:	69a3      	ldr	r3, [r4, #24]
}
  20070a:	6a58      	ldr	r0, [r3, #36]	; 0x24
  20070c:	b006      	add	sp, #24
  20070e:	bd70      	pop	{r4, r5, r6, pc}
  200710:	20000810 	.word	0x20000810
  200714:	002004d1 	.word	0x002004d1
	...

00200720 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return              the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
  200720:	b510      	push	{r4, lr}
  200722:	2320      	movs	r3, #32
  200724:	460c      	mov	r4, r1
  200726:	f383 8811 	msr	BASEPRI, r3
  return ch.vtlist.systime;
  20072a:	4b09      	ldr	r3, [pc, #36]	; (200750 <chThdSleepUntilWindowed+0x30>)
  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
  20072c:	1a0a      	subs	r2, r1, r0
  return ch.vtlist.systime;
  20072e:	8cdb      	ldrh	r3, [r3, #38]	; 0x26
  systime_t time;

  chSysLock();
  time = chVTGetSystemTimeX();
  if (chVTIsTimeWithinX(time, prev, next)) {
  200730:	b292      	uxth	r2, r2
  200732:	b29b      	uxth	r3, r3
  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
  200734:	1a18      	subs	r0, r3, r0
  200736:	b280      	uxth	r0, r0
  200738:	4290      	cmp	r0, r2
  20073a:	d203      	bcs.n	200744 <chThdSleepUntilWindowed+0x24>
    chThdSleepS(next - time);
  20073c:	1ac8      	subs	r0, r1, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
  20073e:	b280      	uxth	r0, r0
  200740:	f7ff ffa6 	bl	200690 <chSchGoSleepTimeoutS.constprop.5>
  200744:	2300      	movs	r3, #0
  200746:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return next;
}
  20074a:	4620      	mov	r0, r4
  20074c:	bd10      	pop	{r4, pc}
  20074e:	bf00      	nop
  200750:	20000810 	.word	0x20000810
	...

00200760 <Blinker1>:
#include <ch.h>
#include <hal.h>
#include <chprintf.h>

static THD_WORKING_AREA(waBlinker1, 128);
static THD_FUNCTION(Blinker1, arg) {
  200760:	b508      	push	{r3, lr}
  200762:	2320      	movs	r3, #32
  200764:	f383 8811 	msr	BASEPRI, r3
  return ch.vtlist.systime;
  200768:	4a08      	ldr	r2, [pc, #32]	; (20078c <Blinker1+0x2c>)
  20076a:	2300      	movs	r3, #0
  20076c:	8cd0      	ldrh	r0, [r2, #38]	; 0x26
  20076e:	b280      	uxth	r0, r0
  200770:	f383 8811 	msr	BASEPRI, r3

    (void)arg;
    systime_t prev = chVTGetSystemTime(); // Current system time.
    while (true) {
        palToggleLine(LINE_LED1);
  200774:	4c06      	ldr	r4, [pc, #24]	; (200790 <Blinker1+0x30>)
  200776:	6963      	ldr	r3, [r4, #20]
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  200778:	f500 71fa 	add.w	r1, r0, #500	; 0x1f4
        palToggleLine(LINE_LED1);
  20077c:	f083 0301 	eor.w	r3, r3, #1
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  200780:	b289      	uxth	r1, r1
        palToggleLine(LINE_LED1);
  200782:	6163      	str	r3, [r4, #20]
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  200784:	f7ff ffcc 	bl	200720 <chThdSleepUntilWindowed>
  200788:	e7f5      	b.n	200776 <Blinker1+0x16>
  20078a:	bf00      	nop
  20078c:	20000810 	.word	0x20000810
  200790:	40020400 	.word	0x40020400
	...

002007a0 <Blinker2>:
    }

}

static THD_WORKING_AREA(waBlinker2, 128);
static THD_FUNCTION(Blinker2, arg) {
  2007a0:	b508      	push	{r3, lr}
  2007a2:	2320      	movs	r3, #32
  2007a4:	f383 8811 	msr	BASEPRI, r3
  2007a8:	4a08      	ldr	r2, [pc, #32]	; (2007cc <Blinker2+0x2c>)
  2007aa:	2300      	movs	r3, #0
  2007ac:	8cd0      	ldrh	r0, [r2, #38]	; 0x26
  2007ae:	b280      	uxth	r0, r0
  2007b0:	f383 8811 	msr	BASEPRI, r3

    (void)arg;
    systime_t prev = chVTGetSystemTime(); // Current system time.
    while (true) {
        palToggleLine(LINE_LED2);
  2007b4:	4c06      	ldr	r4, [pc, #24]	; (2007d0 <Blinker2+0x30>)
  2007b6:	6963      	ldr	r3, [r4, #20]
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  2007b8:	f500 71fa 	add.w	r1, r0, #500	; 0x1f4
        palToggleLine(LINE_LED2);
  2007bc:	f083 0380 	eor.w	r3, r3, #128	; 0x80
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  2007c0:	b289      	uxth	r1, r1
        palToggleLine(LINE_LED2);
  2007c2:	6163      	str	r3, [r4, #20]
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  2007c4:	f7ff ffac 	bl	200720 <chThdSleepUntilWindowed>
  2007c8:	e7f5      	b.n	2007b6 <Blinker2+0x16>
  2007ca:	bf00      	nop
  2007cc:	20000810 	.word	0x20000810
  2007d0:	40020400 	.word	0x40020400
	...

002007e0 <Blinker3>:
    }
}

static THD_WORKING_AREA(waBlinker3, 128);
static THD_FUNCTION(Blinker3, arg) {
  2007e0:	b508      	push	{r3, lr}
  2007e2:	2320      	movs	r3, #32
  2007e4:	f383 8811 	msr	BASEPRI, r3
  2007e8:	4a08      	ldr	r2, [pc, #32]	; (20080c <Blinker3+0x2c>)
  2007ea:	2300      	movs	r3, #0
  2007ec:	8cd0      	ldrh	r0, [r2, #38]	; 0x26
  2007ee:	b280      	uxth	r0, r0
  2007f0:	f383 8811 	msr	BASEPRI, r3

    (void)arg;
    systime_t prev = chVTGetSystemTime(); // Current system time.
    while (true) {
        palToggleLine(LINE_LED3);
  2007f4:	4c06      	ldr	r4, [pc, #24]	; (200810 <Blinker3+0x30>)
  2007f6:	6963      	ldr	r3, [r4, #20]
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  2007f8:	f500 71fa 	add.w	r1, r0, #500	; 0x1f4
        palToggleLine(LINE_LED3);
  2007fc:	f483 4380 	eor.w	r3, r3, #16384	; 0x4000
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  200800:	b289      	uxth	r1, r1
        palToggleLine(LINE_LED3);
  200802:	6163      	str	r3, [r4, #20]
        prev = chThdSleepUntilWindowed(prev, prev + MS2ST(500));
  200804:	f7ff ff8c 	bl	200720 <chThdSleepUntilWindowed>
  200808:	e7f5      	b.n	2007f6 <Blinker3+0x16>
  20080a:	bf00      	nop
  20080c:	20000810 	.word	0x20000810
  200810:	40020400 	.word	0x40020400
	...

00200820 <main>:
  tqp->next = (thread_t *)tqp;
  200820:	4cbd      	ldr	r4, [pc, #756]	; (200b18 <main+0x2f8>)
  ch.rlist.prio = NOPRIO;
  200822:	2500      	movs	r5, #0
  ch.vtlist.delta = (systime_t)-1;
  200824:	f64f 72ff 	movw	r2, #65535	; 0xffff
  tmp->best       = (rtcnt_t)-1;
  200828:	f04f 36ff 	mov.w	r6, #4294967295
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  20082c:	f104 031c 	add.w	r3, r4, #28
  tmp->cumulative = (rttime_t)0;
  200830:	f04f 0800 	mov.w	r8, #0
  200834:	f04f 0900 	mov.w	r9, #0
    }
}

int main(void)
{
  200838:	b580      	push	{r7, lr}
  20083a:	b086      	sub	sp, #24
  20083c:	6024      	str	r4, [r4, #0]
  tqp->prev = (thread_t *)tqp;
  20083e:	6064      	str	r4, [r4, #4]
  chTMStartMeasurementX(&tm);
  200840:	4668      	mov	r0, sp
  ch.vtlist.delta = (systime_t)-1;
  200842:	84a2      	strh	r2, [r4, #36]	; 0x24
  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
  200844:	61e3      	str	r3, [r4, #28]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  200846:	6223      	str	r3, [r4, #32]
  ch.rlist.newer = (thread_t *)&ch.rlist;
  200848:	6124      	str	r4, [r4, #16]
  ch.rlist.older = (thread_t *)&ch.rlist;
  20084a:	6164      	str	r4, [r4, #20]
  ch.rlist.prio = NOPRIO;
  20084c:	60a5      	str	r5, [r4, #8]
  ch.vtlist.systime = (systime_t)0;
  20084e:	84e5      	strh	r5, [r4, #38]	; 0x26
  ch.tm.offset = (rtcnt_t)0;
  200850:	6725      	str	r5, [r4, #112]	; 0x70
  tmp->worst      = (rtcnt_t)0;
  200852:	9501      	str	r5, [sp, #4]
  tmp->last       = (rtcnt_t)0;
  200854:	9502      	str	r5, [sp, #8]
  tmp->n          = (ucnt_t)0;
  200856:	9503      	str	r5, [sp, #12]
  tmp->best       = (rtcnt_t)-1;
  200858:	9600      	str	r6, [sp, #0]
  tmp->cumulative = (rttime_t)0;
  20085a:	e9cd 8904 	strd	r8, r9, [sp, #16]
  chTMStartMeasurementX(&tm);
  20085e:	f7ff fd4f 	bl	200300 <chTMStartMeasurementX.constprop.7>
  chTMStopMeasurementX(&tm);
  200862:	4668      	mov	r0, sp
  200864:	f7ff fe0c 	bl	200480 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
  200868:	4bac      	ldr	r3, [pc, #688]	; (200b1c <main+0x2fc>)
  20086a:	49ad      	ldr	r1, [pc, #692]	; (200b20 <main+0x300>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  20086c:	f64f 09ff 	movw	r9, #63743	; 0xf8ff
  nextmem = __heap_base__;
  200870:	4aac      	ldr	r2, [pc, #688]	; (200b24 <main+0x304>)
  REG_INSERT(tp);
  200872:	f104 002c 	add.w	r0, r4, #44	; 0x2c
  200876:	6019      	str	r1, [r3, #0]
  tqp->next = (thread_t *)tqp;
  200878:	f103 0810 	add.w	r8, r3, #16
  20087c:	49aa      	ldr	r1, [pc, #680]	; (200b28 <main+0x308>)
  tp->prio      = prio;
  20087e:	f04f 0c80 	mov.w	ip, #128	; 0x80
  ch.tm.offset = tm.last;
  200882:	9f02      	ldr	r7, [sp, #8]
  200884:	6011      	str	r1, [r2, #0]
  endmem  = __heap_end__;
  200886:	4aa9      	ldr	r2, [pc, #676]	; (200b2c <main+0x30c>)
  200888:	49a9      	ldr	r1, [pc, #676]	; (200b30 <main+0x310>)
  tp->flags     = CH_FLAG_MODE_STATIC;
  20088a:	f884 504d 	strb.w	r5, [r4, #77]	; 0x4d
  20088e:	6011      	str	r1, [r2, #0]
  tp->refs      = (trefs_t)1;
  200890:	2201      	movs	r2, #1
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  200892:	49a8      	ldr	r1, [pc, #672]	; (200b34 <main+0x314>)
  tp->mtxlist   = NULL;
  200894:	6665      	str	r5, [r4, #100]	; 0x64
  200896:	f8d1 e00c 	ldr.w	lr, [r1, #12]
  20089a:	6727      	str	r7, [r4, #112]	; 0x70
  tp->name      = name;
  20089c:	4fa6      	ldr	r7, [pc, #664]	; (200b38 <main+0x318>)
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  20089e:	ea0e 0e09 	and.w	lr, lr, r9
  tp->prio      = prio;
  2008a2:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
  tp->name      = name;
  2008a6:	6467      	str	r7, [r4, #68]	; 0x44
  reg_value  =  (reg_value                                   |
  2008a8:	4fa4      	ldr	r7, [pc, #656]	; (200b3c <main+0x31c>)
  tp->realprio  = prio;
  2008aa:	f8c4 c068 	str.w	ip, [r4, #104]	; 0x68
  tlp->next = (thread_t *)tlp;
  2008ae:	f104 0c54 	add.w	ip, r4, #84	; 0x54
  2008b2:	ea4e 0707 	orr.w	r7, lr, r7
  REG_INSERT(tp);
  2008b6:	f8d4 e014 	ldr.w	lr, [r4, #20]
  tp->epending  = (eventmask_t)0;
  2008ba:	6625      	str	r5, [r4, #96]	; 0x60
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
  2008bc:	619d      	str	r5, [r3, #24]
  tqp->next = (thread_t *)tqp;
  2008be:	f8c3 8010 	str.w	r8, [r3, #16]
  tqp->prev = (thread_t *)tqp;
  2008c2:	f8c3 8014 	str.w	r8, [r3, #20]
  tp->refs      = (trefs_t)1;
  2008c6:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e
  REG_INSERT(tp);
  2008ca:	f8c4 e040 	str.w	lr, [r4, #64]	; 0x40
  2008ce:	63e4      	str	r4, [r4, #60]	; 0x3c
  2008d0:	f8ce 0010 	str.w	r0, [lr, #16]
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  2008d4:	f8df e2b8 	ldr.w	lr, [pc, #696]	; 200b90 <main+0x370>
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
  2008d8:	60cf      	str	r7, [r1, #12]
  tqp->next = (thread_t *)tqp;
  2008da:	f104 0758 	add.w	r7, r4, #88	; 0x58
  H_NEXT(&default_heap.header) = NULL;
  2008de:	609d      	str	r5, [r3, #8]
  H_PAGES(&default_heap.header) = 0;
  2008e0:	60dd      	str	r5, [r3, #12]
  2008e2:	f8de 300c 	ldr.w	r3, [lr, #12]
  2008e6:	6160      	str	r0, [r4, #20]
  2008e8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
  2008ec:	61a0      	str	r0, [r4, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
  2008ee:	64a5      	str	r5, [r4, #72]	; 0x48
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
  2008f0:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
  tlp->next = (thread_t *)tlp;
  2008f4:	f8c4 c054 	str.w	ip, [r4, #84]	; 0x54
  DWT->LAR = 0xC5ACCE55U;
  2008f8:	4891      	ldr	r0, [pc, #580]	; (200b40 <main+0x320>)
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
  2008fa:	f8ce 300c 	str.w	r3, [lr, #12]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHPR[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  2008fe:	f04f 0e10 	mov.w	lr, #16
  DWT->LAR = 0xC5ACCE55U;
  200902:	4b90      	ldr	r3, [pc, #576]	; (200b44 <main+0x324>)
  tqp->next = (thread_t *)tqp;
  200904:	65a7      	str	r7, [r4, #88]	; 0x58
  tqp->prev = (thread_t *)tqp;
  200906:	65e7      	str	r7, [r4, #92]	; 0x5c
  200908:	2720      	movs	r7, #32
  20090a:	f8c3 0fb0 	str.w	r0, [r3, #4016]	; 0xfb0
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
  20090e:	6818      	ldr	r0, [r3, #0]
  200910:	4310      	orrs	r0, r2
  200912:	6018      	str	r0, [r3, #0]
  200914:	f881 e01f 	strb.w	lr, [r1, #31]
  200918:	f881 7022 	strb.w	r7, [r1, #34]	; 0x22
  20091c:	f385 8811 	msr	BASEPRI, r5
  __ASM volatile ("cpsie i" : : : "memory");
  200920:	b662      	cpsie	i
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
  200922:	f387 8811 	msr	BASEPRI, r7
  tp->wabase = tdp->wbase;
  200926:	4b88      	ldr	r3, [pc, #544]	; (200b48 <main+0x328>)
  tp->state     = CH_STATE_WTSTART;
  200928:	f04f 0c02 	mov.w	ip, #2
  REG_INSERT(tp);
  20092c:	6967      	ldr	r7, [r4, #20]
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  20092e:	f103 006c 	add.w	r0, r3, #108	; 0x6c
  tp->state     = CH_STATE_WTSTART;
  200932:	f883 c0b0 	strb.w	ip, [r3, #176]	; 0xb0
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200936:	f8df c25c 	ldr.w	ip, [pc, #604]	; 200b94 <main+0x374>
  REG_INSERT(tp);
  20093a:	f103 0190 	add.w	r1, r3, #144	; 0x90
  tp->prio      = prio;
  20093e:	f8c3 2098 	str.w	r2, [r3, #152]	; 0x98
  tlp->next = (thread_t *)tlp;
  200942:	f103 0eb8 	add.w	lr, r3, #184	; 0xb8
  tp->realprio  = prio;
  200946:	f8c3 20cc 	str.w	r2, [r3, #204]	; 0xcc
  tp->refs      = (trefs_t)1;
  20094a:	f883 20b2 	strb.w	r2, [r3, #178]	; 0xb2
  tqp->next = (thread_t *)tqp;
  20094e:	f103 02bc 	add.w	r2, r3, #188	; 0xbc
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200952:	f8c3 009c 	str.w	r0, [r3, #156]	; 0x9c
  200956:	f8c3 c08c 	str.w	ip, [r3, #140]	; 0x8c
  20095a:	487c      	ldr	r0, [pc, #496]	; (200b4c <main+0x32c>)
  tp->name      = name;
  20095c:	f8df c238 	ldr.w	ip, [pc, #568]	; 200b98 <main+0x378>
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200960:	66d8      	str	r0, [r3, #108]	; 0x6c
  chSchWakeupS(tp, MSG_OK);
  200962:	4608      	mov	r0, r1
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
  200964:	671d      	str	r5, [r3, #112]	; 0x70
  REG_INSERT(tp);
  200966:	f8c3 70a4 	str.w	r7, [r3, #164]	; 0xa4
  tp->flags     = CH_FLAG_MODE_STATIC;
  20096a:	f883 50b1 	strb.w	r5, [r3, #177]	; 0xb1
  tp->mtxlist   = NULL;
  20096e:	f8c3 50c8 	str.w	r5, [r3, #200]	; 0xc8
  tp->epending  = (eventmask_t)0;
  200972:	f8c3 50c4 	str.w	r5, [r3, #196]	; 0xc4
  REG_INSERT(tp);
  200976:	f8c3 40a0 	str.w	r4, [r3, #160]	; 0xa0
  tp->wabase = tdp->wbase;
  20097a:	f8c3 30ac 	str.w	r3, [r3, #172]	; 0xac
  tp->name      = name;
  20097e:	f8c3 c0a8 	str.w	ip, [r3, #168]	; 0xa8
  REG_INSERT(tp);
  200982:	6139      	str	r1, [r7, #16]
  tlp->next = (thread_t *)tlp;
  200984:	f8c3 e0b8 	str.w	lr, [r3, #184]	; 0xb8
  tqp->next = (thread_t *)tqp;
  200988:	f8c3 20bc 	str.w	r2, [r3, #188]	; 0xbc
  tqp->prev = (thread_t *)tqp;
  20098c:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
  200990:	6161      	str	r1, [r4, #20]
  chSchWakeupS(tp, MSG_OK);
  200992:	f7ff fde5 	bl	200560 <chSchWakeupS.constprop.12>
  200996:	f385 8811 	msr	BASEPRI, r5
 */
void hal_lld_init(void) {

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).*/
  rccResetAHB1(~0);
  20099a:	4b6d      	ldr	r3, [pc, #436]	; (200b50 <main+0x330>)
  PWR->CR1 |= PWR_CR1_DBP;
  20099c:	496d      	ldr	r1, [pc, #436]	; (200b54 <main+0x334>)
  rccResetAHB1(~0);
  20099e:	691a      	ldr	r2, [r3, #16]
  2009a0:	611e      	str	r6, [r3, #16]
  2009a2:	611d      	str	r5, [r3, #16]
  rccResetAHB2(~0);
  2009a4:	695a      	ldr	r2, [r3, #20]
  2009a6:	615e      	str	r6, [r3, #20]
  2009a8:	615d      	str	r5, [r3, #20]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  2009aa:	6a1a      	ldr	r2, [r3, #32]
  2009ac:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
  2009b0:	621a      	str	r2, [r3, #32]
  2009b2:	621d      	str	r5, [r3, #32]
  rccResetAPB2(~0);
  2009b4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
  2009b6:	625e      	str	r6, [r3, #36]	; 0x24
  2009b8:	625d      	str	r5, [r3, #36]	; 0x24
  PWR->CR1 |= PWR_CR1_DBP;
  2009ba:	680a      	ldr	r2, [r1, #0]
  2009bc:	f442 7280 	orr.w	r2, r2, #256	; 0x100
  2009c0:	600a      	str	r2, [r1, #0]
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
  2009c2:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  2009c4:	f402 7240 	and.w	r2, r2, #768	; 0x300
  2009c8:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
  2009cc:	d003      	beq.n	2009d6 <main+0x1b6>
    RCC->BDCR = RCC_BDCR_BDRST;
  2009ce:	f44f 3280 	mov.w	r2, #65536	; 0x10000
  2009d2:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
  2009d4:	671d      	str	r5, [r3, #112]	; 0x70
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2009d6:	4b5e      	ldr	r3, [pc, #376]	; (200b50 <main+0x330>)
  2009d8:	6f1a      	ldr	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2009da:	4618      	mov	r0, r3
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
  2009dc:	f042 0219 	orr.w	r2, r2, #25
  2009e0:	671a      	str	r2, [r3, #112]	; 0x70
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
  2009e2:	6f03      	ldr	r3, [r0, #112]	; 0x70
  2009e4:	079b      	lsls	r3, r3, #30
  2009e6:	d5fc      	bpl.n	2009e2 <main+0x1c2>
  PWR->CSR1 &= ~PWR_CSR1_BRE;
  2009e8:	f8df e168 	ldr.w	lr, [pc, #360]	; 200b54 <main+0x334>
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F2XX) || defined(STM32F4XX) || defined(STM32F7XX)
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  2009ec:	f240 77ff 	movw	r7, #2047	; 0x7ff
  gpiop->OTYPER  = config->otyper;
  2009f0:	2300      	movs	r3, #0
  2009f2:	4959      	ldr	r1, [pc, #356]	; (200b58 <main+0x338>)
  2009f4:	f8de 4004 	ldr.w	r4, [lr, #4]
  gpiop->ODR     = config->odr;
  2009f8:	f64f 72ff 	movw	r2, #65535	; 0xffff
  gpiop->OSPEEDR = config->ospeedr;
  2009fc:	f04f 35ff 	mov.w	r5, #4294967295
  gpiop->PUPDR   = config->pupdr;
  200a00:	4e56      	ldr	r6, [pc, #344]	; (200b5c <main+0x33c>)
  200a02:	f424 7400 	bic.w	r4, r4, #512	; 0x200
  gpiop->AFRL    = config->afrl;
  200a06:	f8df 8194 	ldr.w	r8, [pc, #404]	; 200b9c <main+0x37c>
  gpiop->ODR     = config->odr;
  200a0a:	f64b 797e 	movw	r9, #49022	; 0xbf7e
  gpiop->AFRH    = config->afrh;
  200a0e:	f44f 0c30 	mov.w	ip, #11534336	; 0xb00000
  200a12:	f8ce 4004 	str.w	r4, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
  200a16:	f06f 4e70 	mvn.w	lr, #4026531840	; 0xf0000000
  RCC->AHB1ENR   |= AHB1_EN_MASK;
  200a1a:	6b04      	ldr	r4, [r0, #48]	; 0x30
  200a1c:	433c      	orrs	r4, r7
  200a1e:	6304      	str	r4, [r0, #48]	; 0x30
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
  200a20:	6d04      	ldr	r4, [r0, #80]	; 0x50
  200a22:	433c      	orrs	r4, r7
  gpiop->MODER   = config->moder;
  200a24:	f640 2708 	movw	r7, #2568	; 0xa08
  RCC->AHB1LPENR |= AHB1_LPEN_MASK;
  200a28:	6504      	str	r4, [r0, #80]	; 0x50
  gpiop->AFRH    = config->afrh;
  200a2a:	484d      	ldr	r0, [pc, #308]	; (200b60 <main+0x340>)
  gpiop->OTYPER  = config->otyper;
  200a2c:	604b      	str	r3, [r1, #4]
  gpiop->PUPDR   = config->pupdr;
  200a2e:	4c4d      	ldr	r4, [pc, #308]	; (200b64 <main+0x344>)
  gpiop->OSPEEDR = config->ospeedr;
  200a30:	608d      	str	r5, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
  200a32:	60ce      	str	r6, [r1, #12]
  gpiop->OSPEEDR = config->ospeedr;
  200a34:	f46f 1640 	mvn.w	r6, #3145728	; 0x300000
  gpiop->ODR     = config->odr;
  200a38:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
  200a3a:	f8c1 8020 	str.w	r8, [r1, #32]
  gpiop->AFRH    = config->afrh;
  200a3e:	f04f 0877 	mov.w	r8, #119	; 0x77
  200a42:	6248      	str	r0, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
  200a44:	4848      	ldr	r0, [pc, #288]	; (200b68 <main+0x348>)
  200a46:	6008      	str	r0, [r1, #0]
  200a48:	f44f 2020 	mov.w	r0, #655360	; 0xa0000
  gpiop->OTYPER  = config->otyper;
  200a4c:	f8c1 3404 	str.w	r3, [r1, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  200a50:	f8c1 5408 	str.w	r5, [r1, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
  200a54:	f04f 3555 	mov.w	r5, #1431655765	; 0x55555555
  200a58:	f8c1 440c 	str.w	r4, [r1, #1036]	; 0x40c
  gpiop->MODER   = config->moder;
  200a5c:	f04f 6408 	mov.w	r4, #142606336	; 0x8800000
  gpiop->ODR     = config->odr;
  200a60:	f8c1 9414 	str.w	r9, [r1, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  200a64:	f8c1 3420 	str.w	r3, [r1, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  200a68:	f8c1 c424 	str.w	ip, [r1, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  200a6c:	f8df c130 	ldr.w	ip, [pc, #304]	; 200ba0 <main+0x380>
  gpiop->PUPDR   = config->pupdr;
  200a70:	f8df 9130 	ldr.w	r9, [pc, #304]	; 200ba4 <main+0x384>
  gpiop->MODER   = config->moder;
  200a74:	f8c1 c400 	str.w	ip, [r1, #1024]	; 0x400
  gpiop->OTYPER  = config->otyper;
  200a78:	f501 6100 	add.w	r1, r1, #2048	; 0x800
  200a7c:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
  200a7e:	f04f 0c0f 	mov.w	ip, #15
  200a82:	f8c1 e008 	str.w	lr, [r1, #8]
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {

  gptp->state  = GPT_STOP;
  200a86:	f04f 0e01 	mov.w	lr, #1
  gpiop->PUPDR   = config->pupdr;
  200a8a:	f8c1 900c 	str.w	r9, [r1, #12]
  gpiop->AFRL    = config->afrl;
  200a8e:	f8df 9118 	ldr.w	r9, [pc, #280]	; 200ba8 <main+0x388>
  gpiop->ODR     = config->odr;
  200a92:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
  200a94:	f8c1 9020 	str.w	r9, [r1, #32]
  gpiop->PUPDR   = config->pupdr;
  200a98:	f8df 9110 	ldr.w	r9, [pc, #272]	; 200bac <main+0x38c>
  gpiop->AFRH    = config->afrh;
  200a9c:	624b      	str	r3, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
  200a9e:	600f      	str	r7, [r1, #0]
#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
  200aa0:	2707      	movs	r7, #7
  gpiop->OTYPER  = config->otyper;
  200aa2:	f8c1 3404 	str.w	r3, [r1, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
  200aa6:	f8c1 6408 	str.w	r6, [r1, #1032]	; 0x408

#if defined(__CORE_CM0_H_GENERIC)
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
  200aaa:	2680      	movs	r6, #128	; 0x80
  gpiop->PUPDR   = config->pupdr;
  200aac:	f8c1 940c 	str.w	r9, [r1, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
  200ab0:	f8c1 2414 	str.w	r2, [r1, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
  200ab4:	f8c1 3420 	str.w	r3, [r1, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
  200ab8:	f8c1 8424 	str.w	r8, [r1, #1060]	; 0x424
  gpiop->MODER   = config->moder;
  200abc:	f8c1 0400 	str.w	r0, [r1, #1024]	; 0x400
  gpiop->OSPEEDR = config->ospeedr;
  200ac0:	482a      	ldr	r0, [pc, #168]	; (200b6c <main+0x34c>)
  gpiop->OTYPER  = config->otyper;
  200ac2:	f8c1 3804 	str.w	r3, [r1, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  200ac6:	f8c1 0808 	str.w	r0, [r1, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  200aca:	f8c1 580c 	str.w	r5, [r1, #2060]	; 0x80c
  gpiop->OTYPER  = config->otyper;
  200ace:	4828      	ldr	r0, [pc, #160]	; (200b70 <main+0x350>)
  gpiop->ODR     = config->odr;
  200ad0:	f8c1 2814 	str.w	r2, [r1, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  200ad4:	f8c1 3820 	str.w	r3, [r1, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
  200ad8:	f8c1 3824 	str.w	r3, [r1, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  200adc:	f8c1 3800 	str.w	r3, [r1, #2048]	; 0x800
  gpiop->OSPEEDR = config->ospeedr;
  200ae0:	4924      	ldr	r1, [pc, #144]	; (200b74 <main+0x354>)
  gpiop->OTYPER  = config->otyper;
  200ae2:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  200ae4:	6081      	str	r1, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  200ae6:	60c5      	str	r5, [r0, #12]
  gpiop->OTYPER  = config->otyper;
  200ae8:	4923      	ldr	r1, [pc, #140]	; (200b78 <main+0x358>)
  gpiop->ODR     = config->odr;
  200aea:	6142      	str	r2, [r0, #20]
  gpiop->AFRL    = config->afrl;
  200aec:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
  200aee:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  200af0:	6003      	str	r3, [r0, #0]
  gpiop->OSPEEDR = config->ospeedr;
  200af2:	4822      	ldr	r0, [pc, #136]	; (200b7c <main+0x35c>)
  gpiop->OTYPER  = config->otyper;
  200af4:	604b      	str	r3, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
  200af6:	6088      	str	r0, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
  200af8:	4821      	ldr	r0, [pc, #132]	; (200b80 <main+0x360>)
  200afa:	60c8      	str	r0, [r1, #12]
  gpiop->AFRH    = config->afrh;
  200afc:	4821      	ldr	r0, [pc, #132]	; (200b84 <main+0x364>)
  gpiop->ODR     = config->odr;
  200afe:	614a      	str	r2, [r1, #20]
  gpiop->AFRL    = config->afrl;
  200b00:	620b      	str	r3, [r1, #32]
  gpiop->AFRH    = config->afrh;
  200b02:	6248      	str	r0, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
  200b04:	600c      	str	r4, [r1, #0]
    chSysInit();
    halInit();

    chThdCreateStatic(waBlinker1, sizeof(waBlinker1), NORMALPRIO,     Blinker1, NULL);
  200b06:	4631      	mov	r1, r6
  gpiop->OTYPER  = config->otyper;
  200b08:	4c1f      	ldr	r4, [pc, #124]	; (200b88 <main+0x368>)
  gpiop->PUPDR   = config->pupdr;
  200b0a:	4820      	ldr	r0, [pc, #128]	; (200b8c <main+0x36c>)
  gpiop->OTYPER  = config->otyper;
  200b0c:	6063      	str	r3, [r4, #4]
  gpiop->OSPEEDR = config->ospeedr;
  200b0e:	f8c4 c008 	str.w	ip, [r4, #8]
  gpiop->PUPDR   = config->pupdr;
  200b12:	60e0      	str	r0, [r4, #12]
  200b14:	e04c      	b.n	200bb0 <main+0x390>
  200b16:	bf00      	nop
  200b18:	20000810 	.word	0x20000810
  200b1c:	20000960 	.word	0x20000960
  200b20:	00200311 	.word	0x00200311
  200b24:	20000984 	.word	0x20000984
  200b28:	20020000 	.word	0x20020000
  200b2c:	20000980 	.word	0x20000980
  200b30:	20080000 	.word	0x20080000
  200b34:	e000ed00 	.word	0xe000ed00
  200b38:	08000f34 	.word	0x08000f34
  200b3c:	05fa0300 	.word	0x05fa0300
  200b40:	c5acce55 	.word	0xc5acce55
  200b44:	e0001000 	.word	0xe0001000
  200b48:	20000888 	.word	0x20000888
  200b4c:	00200541 	.word	0x00200541
  200b50:	40023800 	.word	0x40023800
  200b54:	40007000 	.word	0x40007000
  200b58:	40020000 	.word	0x40020000
  200b5c:	40005551 	.word	0x40005551
  200b60:	000aaa0a 	.word	0x000aaa0a
  200b64:	45551554 	.word	0x45551554
  200b68:	2aae8028 	.word	0x2aae8028
  200b6c:	cffffff3 	.word	0xcffffff3
  200b70:	40021400 	.word	0x40021400
  200b74:	003fcfff 	.word	0x003fcfff
  200b78:	40021800 	.word	0x40021800
  200b7c:	3cccf000 	.word	0x3cccf000
  200b80:	51155555 	.word	0x51155555
  200b84:	00b0b000 	.word	0x00b0b000
  200b88:	40021c00 	.word	0x40021c00
  200b8c:	55555550 	.word	0x55555550
  200b90:	e000edf0 	.word	0xe000edf0
  200b94:	002002e5 	.word	0x002002e5
  200b98:	08000f4c 	.word	0x08000f4c
  200b9c:	b0000bb0 	.word	0xb0000bb0
  200ba0:	18004001 	.word	0x18004001
  200ba4:	01555051 	.word	0x01555051
  200ba8:	00bb00b0 	.word	0x00bb00b0
  200bac:	55505555 	.word	0x55505555
  gpiop->OTYPER  = config->otyper;
  200bb0:	4829      	ldr	r0, [pc, #164]	; (200c58 <main+0x438>)
  gpiop->ODR     = config->odr;
  200bb2:	6162      	str	r2, [r4, #20]
  GPTD1.tim = STM32_TIM1;
  200bb4:	f8df c0c8 	ldr.w	ip, [pc, #200]	; 200c80 <main+0x460>
  gpiop->AFRL    = config->afrl;
  200bb8:	6223      	str	r3, [r4, #32]
  gpiop->AFRH    = config->afrh;
  200bba:	6263      	str	r3, [r4, #36]	; 0x24
  gpiop->MODER   = config->moder;
  200bbc:	6023      	str	r3, [r4, #0]
  gpiop->OTYPER  = config->otyper;
  200bbe:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
  200bc0:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  200bc2:	60c5      	str	r5, [r0, #12]
  gpiop->ODR     = config->odr;
  200bc4:	6142      	str	r2, [r0, #20]
  gpiop->AFRL    = config->afrl;
  200bc6:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
  200bc8:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
  200bca:	6003      	str	r3, [r0, #0]
  gpiop->OTYPER  = config->otyper;
  200bcc:	f8c4 3804 	str.w	r3, [r4, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  200bd0:	f8c4 3808 	str.w	r3, [r4, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  200bd4:	f8c4 580c 	str.w	r5, [r4, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
  200bd8:	f8c4 2814 	str.w	r2, [r4, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  200bdc:	f8c4 3820 	str.w	r3, [r4, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
  200be0:	f8c4 3824 	str.w	r3, [r4, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  200be4:	f8c4 3800 	str.w	r3, [r4, #2048]	; 0x800
  200be8:	2420      	movs	r4, #32
  gpiop->OTYPER  = config->otyper;
  200bea:	f8c0 3804 	str.w	r3, [r0, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  200bee:	f8c0 3808 	str.w	r3, [r0, #2056]	; 0x808
  gpiop->PUPDR   = config->pupdr;
  200bf2:	f8c0 580c 	str.w	r5, [r0, #2060]	; 0x80c
  200bf6:	461d      	mov	r5, r3
  gpiop->ODR     = config->odr;
  200bf8:	f8c0 2814 	str.w	r2, [r0, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
  200bfc:	f8c0 3820 	str.w	r3, [r0, #2080]	; 0x820
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  200c00:	4a16      	ldr	r2, [pc, #88]	; (200c5c <main+0x43c>)
  gpiop->AFRH    = config->afrh;
  200c02:	f8c0 3824 	str.w	r3, [r0, #2084]	; 0x824
  gpiop->MODER   = config->moder;
  200c06:	f8c0 3800 	str.w	r3, [r0, #2048]	; 0x800
  200c0a:	4815      	ldr	r0, [pc, #84]	; (200c60 <main+0x440>)
  200c0c:	f88c e000 	strb.w	lr, [ip]
  gptp->config = NULL;
  200c10:	f8cc 3004 	str.w	r3, [ip, #4]
  200c14:	6050      	str	r0, [r2, #4]
  SysTick->VAL = 0;
  200c16:	6093      	str	r3, [r2, #8]
  200c18:	4b12      	ldr	r3, [pc, #72]	; (200c64 <main+0x444>)
  200c1a:	f8df e068 	ldr.w	lr, [pc, #104]	; 200c84 <main+0x464>
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
  200c1e:	6017      	str	r7, [r2, #0]
  200c20:	4811      	ldr	r0, [pc, #68]	; (200c68 <main+0x448>)
  200c22:	f883 6023 	strb.w	r6, [r3, #35]	; 0x23
  200c26:	4a11      	ldr	r2, [pc, #68]	; (200c6c <main+0x44c>)
  200c28:	f8cc e00c 	str.w	lr, [ip, #12]
  200c2c:	f7ff fcc8 	bl	2005c0 <chThdCreateStatic.constprop.4>
    chThdCreateStatic(waBlinker2, sizeof(waBlinker2), NORMALPRIO - 1, Blinker2, NULL);
  200c30:	4a0f      	ldr	r2, [pc, #60]	; (200c70 <main+0x450>)
  200c32:	217f      	movs	r1, #127	; 0x7f
  200c34:	480f      	ldr	r0, [pc, #60]	; (200c74 <main+0x454>)
  200c36:	f7ff fcc3 	bl	2005c0 <chThdCreateStatic.constprop.4>
    chThdCreateStatic(waBlinker3, sizeof(waBlinker3), NORMALPRIO - 2, Blinker3, NULL);
  200c3a:	4a0f      	ldr	r2, [pc, #60]	; (200c78 <main+0x458>)
  200c3c:	217e      	movs	r1, #126	; 0x7e
  200c3e:	480f      	ldr	r0, [pc, #60]	; (200c7c <main+0x45c>)
  200c40:	f7ff fcbe 	bl	2005c0 <chThdCreateStatic.constprop.4>
  200c44:	f384 8811 	msr	BASEPRI, r4
  200c48:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
  200c4c:	f7ff fd20 	bl	200690 <chSchGoSleepTimeoutS.constprop.5>
  200c50:	f385 8811 	msr	BASEPRI, r5
  200c54:	e7f6      	b.n	200c44 <main+0x424>
  200c56:	bf00      	nop
  200c58:	40022000 	.word	0x40022000
  200c5c:	e000e010 	.word	0xe000e010
  200c60:	00034bbf 	.word	0x00034bbf
  200c64:	e000ed00 	.word	0xe000ed00
  200c68:	20000988 	.word	0x20000988
  200c6c:	00200761 	.word	0x00200761
  200c70:	002007a1 	.word	0x002007a1
  200c74:	20000ad0 	.word	0x20000ad0
  200c78:	002007e1 	.word	0x002007e1
  200c7c:	20000c18 	.word	0x20000c18
  200c80:	20000800 	.word	0x20000800
  200c84:	40010000 	.word	0x40010000
	...

00200c90 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
  200c90:	b430      	push	{r4, r5}
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enabled.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  200c92:	4b33      	ldr	r3, [pc, #204]	; (200d60 <__early_init+0xd0>)
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
#endif

  /* PWR initialization.*/
  PWR->CR1 = STM32_VOS;
  200c94:	f44f 4040 	mov.w	r0, #49152	; 0xc000
  200c98:	4a32      	ldr	r2, [pc, #200]	; (200d64 <__early_init+0xd4>)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  200c9a:	4c33      	ldr	r4, [pc, #204]	; (200d68 <__early_init+0xd8>)

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  while (!(RCC->CR & RCC_CR_HSIRDY))
  200c9c:	4619      	mov	r1, r3
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCEN;
  200c9e:	641c      	str	r4, [r3, #64]	; 0x40
  PWR->CR1 = STM32_VOS;
  200ca0:	6010      	str	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
  200ca2:	681a      	ldr	r2, [r3, #0]
  200ca4:	f042 0201 	orr.w	r2, r2, #1
  200ca8:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
  200caa:	680b      	ldr	r3, [r1, #0]
  200cac:	079b      	lsls	r3, r3, #30
  200cae:	d5fc      	bpl.n	200caa <__early_init+0x1a>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  200cb0:	688b      	ldr	r3, [r1, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  200cb2:	4a2b      	ldr	r2, [pc, #172]	; (200d60 <__early_init+0xd0>)
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
  200cb4:	f023 0303 	bic.w	r3, r3, #3
  200cb8:	608b      	str	r3, [r1, #8]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
  200cba:	688b      	ldr	r3, [r1, #8]
  200cbc:	608b      	str	r3, [r1, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
  200cbe:	6893      	ldr	r3, [r2, #8]
  200cc0:	f013 030c 	ands.w	r3, r3, #12
  200cc4:	d1fb      	bne.n	200cbe <__early_init+0x2e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  200cc6:	6810      	ldr	r0, [r2, #0]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  200cc8:	4925      	ldr	r1, [pc, #148]	; (200d60 <__early_init+0xd0>)
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
  200cca:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
  200cce:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
  200cd0:	6093      	str	r3, [r2, #8]
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
  200cd2:	6813      	ldr	r3, [r2, #0]
  200cd4:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
  200cd8:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
  200cda:	680b      	ldr	r3, [r1, #0]
  200cdc:	039d      	lsls	r5, r3, #14
  200cde:	d5fc      	bpl.n	200cda <__early_init+0x4a>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  200ce0:	4b22      	ldr	r3, [pc, #136]	; (200d6c <__early_init+0xdc>)
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;

  /* Synchronization with voltage regulator stabilization.*/
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  200ce2:	4820      	ldr	r0, [pc, #128]	; (200d64 <__early_init+0xd4>)
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
  200ce4:	604b      	str	r3, [r1, #4]
  RCC->CR |= RCC_CR_PLLON;
  200ce6:	680b      	ldr	r3, [r1, #0]
  200ce8:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
  200cec:	600b      	str	r3, [r1, #0]
  while ((PWR->CSR1 & PWR_CSR1_VOSRDY) == 0)
  200cee:	6843      	ldr	r3, [r0, #4]
  200cf0:	045c      	lsls	r4, r3, #17
  200cf2:	d5fc      	bpl.n	200cee <__early_init+0x5e>
    ;                           /* Waits until power regulator is stable.   */

#if STM32_OVERDRIVE_REQUIRED
  /* Overdrive activation performed after activating the PLL in order to save
     time as recommended in RM in "Entering Over-drive mode" paragraph.*/
  PWR->CR1 |= PWR_CR1_ODEN;
  200cf4:	6803      	ldr	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  200cf6:	4a1b      	ldr	r2, [pc, #108]	; (200d64 <__early_init+0xd4>)
  PWR->CR1 |= PWR_CR1_ODEN;
  200cf8:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  200cfc:	6003      	str	r3, [r0, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODRDY))
  200cfe:	6853      	ldr	r3, [r2, #4]
  200d00:	03d9      	lsls	r1, r3, #15
  200d02:	d5fc      	bpl.n	200cfe <__early_init+0x6e>
      ;
  PWR->CR1 |= PWR_CR1_ODSWEN;
  200d04:	6813      	ldr	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  200d06:	4917      	ldr	r1, [pc, #92]	; (200d64 <__early_init+0xd4>)
  PWR->CR1 |= PWR_CR1_ODSWEN;
  200d08:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  200d0c:	6013      	str	r3, [r2, #0]
  while (!(PWR->CSR1 & PWR_CSR1_ODSWRDY))
  200d0e:	684b      	ldr	r3, [r1, #4]
  200d10:	039a      	lsls	r2, r3, #14
  200d12:	d5fc      	bpl.n	200d0e <__early_init+0x7e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
  200d14:	4a12      	ldr	r2, [pc, #72]	; (200d60 <__early_init+0xd0>)
  200d16:	6813      	ldr	r3, [r2, #0]
  200d18:	019b      	lsls	r3, r3, #6
  200d1a:	d5fc      	bpl.n	200d16 <__early_init+0x86>
                  STM32_UART7SEL  | STM32_USART6SEL | STM32_UART5SEL  |
                  STM32_UART4SEL  | STM32_USART3SEL | STM32_USART2SEL |
                  STM32_USART1SEL;

  /* Flash setup.*/
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  200d1c:	4b14      	ldr	r3, [pc, #80]	; (200d70 <__early_init+0xe0>)
  200d1e:	f240 3109 	movw	r1, #777	; 0x309
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  200d22:	4d14      	ldr	r5, [pc, #80]	; (200d74 <__early_init+0xe4>)
    RCC->DCKCFGR1 = dckcfgr1;
  200d24:	f240 2402 	movw	r4, #514	; 0x202
  RCC->DCKCFGR2 = STM32_SDMMCSEL  | STM32_CK48MSEL  | STM32_CECSEL    |
  200d28:	2000      	movs	r0, #0
  RCC->CFGR = STM32_MCO2SEL | STM32_MCO2PRE | STM32_MCO1PRE | STM32_I2SSRC |
  200d2a:	6095      	str	r5, [r2, #8]
    RCC->DCKCFGR1 = dckcfgr1;
  200d2c:	f8c2 408c 	str.w	r4, [r2, #140]	; 0x8c
  RCC->DCKCFGR2 = STM32_SDMMCSEL  | STM32_CK48MSEL  | STM32_CECSEL    |
  200d30:	f8c2 0090 	str.w	r0, [r2, #144]	; 0x90
  FLASH->ACR = FLASH_ACR_ARTEN | FLASH_ACR_PRFTEN | STM32_FLASHBITS;
  200d34:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  200d36:	6893      	ldr	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  200d38:	4909      	ldr	r1, [pc, #36]	; (200d60 <__early_init+0xd0>)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  200d3a:	f043 0302 	orr.w	r3, r3, #2
  200d3e:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
  200d40:	688b      	ldr	r3, [r1, #8]
  200d42:	f003 030c 	and.w	r3, r3, #12
  200d46:	2b08      	cmp	r3, #8
  200d48:	d1fa      	bne.n	200d40 <__early_init+0xb0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
  200d4a:	6c4b      	ldr	r3, [r1, #68]	; 0x44
  200d4c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
  200d50:	644b      	str	r3, [r1, #68]	; 0x44
  200d52:	6e4b      	ldr	r3, [r1, #100]	; 0x64
  200d54:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000

  stm32_clock_init();
}
  200d58:	bc30      	pop	{r4, r5}
  200d5a:	664b      	str	r3, [r1, #100]	; 0x64
  200d5c:	4770      	bx	lr
  200d5e:	bf00      	nop
  200d60:	40023800 	.word	0x40023800
  200d64:	40007000 	.word	0x40007000
  200d68:	10000400 	.word	0x10000400
  200d6c:	09406c08 	.word	0x09406c08
  200d70:	40023c00 	.word	0x40023c00
  200d74:	30999400 	.word	0x30999400
	...

00200d80 <chThdExit>:
void chThdExit(msg_t msg) {
  200d80:	b470      	push	{r4, r5, r6}
  200d82:	2320      	movs	r3, #32
  200d84:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = currp;
  200d88:	4b15      	ldr	r3, [pc, #84]	; (200de0 <chThdExit+0x60>)
  200d8a:	699d      	ldr	r5, [r3, #24]
  while (list_notempty(&tp->waiting)) {
  200d8c:	f105 0628 	add.w	r6, r5, #40	; 0x28
  return (bool)(tlp->next != (thread_t *)tlp);
  200d90:	6aac      	ldr	r4, [r5, #40]	; 0x28
  tp->u.exitcode = msg;
  200d92:	6268      	str	r0, [r5, #36]	; 0x24
  while (list_notempty(&tp->waiting)) {
  200d94:	42a6      	cmp	r6, r4
  200d96:	d012      	beq.n	200dbe <chThdExit+0x3e>
  tp->state = CH_STATE_READY;
  200d98:	2000      	movs	r0, #0
  tlp->next = tp->queue.next;
  200d9a:	6822      	ldr	r2, [r4, #0]
  cp = (thread_t *)&ch.rlist.queue;
  200d9c:	4b10      	ldr	r3, [pc, #64]	; (200de0 <chThdExit+0x60>)
  200d9e:	68a1      	ldr	r1, [r4, #8]
  200da0:	62aa      	str	r2, [r5, #40]	; 0x28
  tp->state = CH_STATE_READY;
  200da2:	f884 0020 	strb.w	r0, [r4, #32]
    cp = cp->queue.next;
  200da6:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
  200da8:	689a      	ldr	r2, [r3, #8]
  200daa:	428a      	cmp	r2, r1
  200dac:	d2fb      	bcs.n	200da6 <chThdExit+0x26>
  tp->queue.prev             = cp->queue.prev;
  200dae:	685a      	ldr	r2, [r3, #4]
  tp->queue.next             = cp;
  200db0:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  200db2:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  200db4:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  200db6:	605c      	str	r4, [r3, #4]
  return (bool)(tlp->next != (thread_t *)tlp);
  200db8:	6aac      	ldr	r4, [r5, #40]	; 0x28
  200dba:	42b4      	cmp	r4, r6
  200dbc:	d1ed      	bne.n	200d9a <chThdExit+0x1a>
  if ((tp->refs == (trefs_t)0) &&
  200dbe:	f895 3022 	ldrb.w	r3, [r5, #34]	; 0x22
  200dc2:	b943      	cbnz	r3, 200dd6 <chThdExit+0x56>
  200dc4:	f895 3021 	ldrb.w	r3, [r5, #33]	; 0x21
  200dc8:	079b      	lsls	r3, r3, #30
  200dca:	d104      	bne.n	200dd6 <chThdExit+0x56>
    REG_REMOVE(tp);
  200dcc:	692a      	ldr	r2, [r5, #16]
  200dce:	696b      	ldr	r3, [r5, #20]
  200dd0:	611a      	str	r2, [r3, #16]
  200dd2:	692a      	ldr	r2, [r5, #16]
  200dd4:	6153      	str	r3, [r2, #20]
  chSchGoSleepS(CH_STATE_FINAL);
  200dd6:	200f      	movs	r0, #15
}
  200dd8:	bc70      	pop	{r4, r5, r6}
  chSchGoSleepS(CH_STATE_FINAL);
  200dda:	f7ff bc41 	b.w	200660 <chSchGoSleepS>
  200dde:	bf00      	nop
  200de0:	20000810 	.word	0x20000810
	...

00200df0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
  200df0:	4a0e      	ldr	r2, [pc, #56]	; (200e2c <chSchDoReschedule+0x3c>)

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
  200df2:	2101      	movs	r1, #1
  thread_t *tp = tqp->next;
  200df4:	6810      	ldr	r0, [r2, #0]
void chSchDoReschedule(void) {
  200df6:	b430      	push	{r4, r5}
  tqp->next             = tp->queue.next;
  200df8:	6803      	ldr	r3, [r0, #0]
  tp->state = CH_STATE_READY;
  200dfa:	2500      	movs	r5, #0
  thread_t *otp = currp;
  200dfc:	6994      	ldr	r4, [r2, #24]
  200dfe:	6013      	str	r3, [r2, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
  200e00:	605a      	str	r2, [r3, #4]
  currp->state = CH_STATE_CURRENT;
  200e02:	f880 1020 	strb.w	r1, [r0, #32]
  tp->state = CH_STATE_READY;
  200e06:	f884 5020 	strb.w	r5, [r4, #32]

  /* Handling idle-leave hook.*/
  if (otp->prio == IDLEPRIO) {
  200e0a:	68a1      	ldr	r1, [r4, #8]
  currp = queue_fifo_remove(&ch.rlist.queue);
  200e0c:	6190      	str	r0, [r2, #24]
  200e0e:	e000      	b.n	200e12 <chSchDoReschedule+0x22>
  200e10:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio > tp->prio);
  200e12:	689a      	ldr	r2, [r3, #8]
  200e14:	4291      	cmp	r1, r2
  200e16:	d3fb      	bcc.n	200e10 <chSchDoReschedule+0x20>
  tp->queue.prev             = cp->queue.prev;
  200e18:	685a      	ldr	r2, [r3, #4]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
  200e1a:	4621      	mov	r1, r4
  tp->queue.next             = cp;
  200e1c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  200e1e:	6062      	str	r2, [r4, #4]
  tp->queue.prev->queue.next = tp;
  200e20:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
  200e22:	605c      	str	r4, [r3, #4]
}
  200e24:	bc30      	pop	{r4, r5}
  chSysSwitch(currp, otp);
  200e26:	f7ff ba55 	b.w	2002d4 <_port_switch>
  200e2a:	bf00      	nop
  200e2c:	20000810 	.word	0x20000810

00200e30 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
  200e30:	b5f0      	push	{r4, r5, r6, r7, lr}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
  200e32:	4f12      	ldr	r7, [pc, #72]	; (200e7c <__init_ram_areas+0x4c>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
  200e34:	2600      	movs	r6, #0
void __init_ram_areas(void) {
  200e36:	4d12      	ldr	r5, [pc, #72]	; (200e80 <__init_ram_areas+0x50>)
  200e38:	f107 0e80 	add.w	lr, r7, #128	; 0x80
  200e3c:	4c11      	ldr	r4, [pc, #68]	; (200e84 <__init_ram_areas+0x54>)
  200e3e:	4b12      	ldr	r3, [pc, #72]	; (200e88 <__init_ram_areas+0x58>)
  200e40:	4912      	ldr	r1, [pc, #72]	; (200e8c <__init_ram_areas+0x5c>)
    while (p < rap->clear_area) {
  200e42:	429c      	cmp	r4, r3
  200e44:	d911      	bls.n	200e6a <__init_ram_areas+0x3a>
  200e46:	3904      	subs	r1, #4
  200e48:	461a      	mov	r2, r3
      *p = *tp;
  200e4a:	f851 0f04 	ldr.w	r0, [r1, #4]!
  200e4e:	f842 0b04 	str.w	r0, [r2], #4
    while (p < rap->clear_area) {
  200e52:	4294      	cmp	r4, r2
  200e54:	d8f9      	bhi.n	200e4a <__init_ram_areas+0x1a>
  200e56:	43da      	mvns	r2, r3
  200e58:	4414      	add	r4, r2
  200e5a:	f024 0403 	bic.w	r4, r4, #3
  200e5e:	3404      	adds	r4, #4
  200e60:	4423      	add	r3, r4
    while (p < rap->no_init_area) {
  200e62:	429d      	cmp	r5, r3
  200e64:	d903      	bls.n	200e6e <__init_ram_areas+0x3e>
      *p = 0;
  200e66:	f843 6b04 	str.w	r6, [r3], #4
    while (p < rap->no_init_area) {
  200e6a:	429d      	cmp	r5, r3
  200e6c:	d8fb      	bhi.n	200e66 <__init_ram_areas+0x36>
      p++;
    }
    rap++;
  200e6e:	3710      	adds	r7, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
  200e70:	4577      	cmp	r7, lr
  200e72:	d202      	bcs.n	200e7a <__init_ram_areas+0x4a>
  200e74:	e897 003a 	ldmia.w	r7, {r1, r3, r4, r5}
  200e78:	e7e3      	b.n	200e42 <__init_ram_areas+0x12>
  200e7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
  200e7c:	08000f54 	.word	0x08000f54
  200e80:	20020000 	.word	0x20020000
  200e84:	20020000 	.word	0x20020000
  200e88:	20020000 	.word	0x20020000
  200e8c:	08000fd4 	.word	0x08000fd4

00200e90 <__default_exit>:
void __default_exit(void) {
  200e90:	e7fe      	b.n	200e90 <__default_exit>
  200e92:	bf00      	nop
	...

00200ea0 <__late_init>:
void __late_init(void) {}
  200ea0:	4770      	bx	lr
  200ea2:	bf00      	nop
	...

00200eb0 <__core_init>:
void __core_init(void) {
  200eb0:	b5f0      	push	{r4, r5, r6, r7, lr}
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__((always_inline)) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
  200eb2:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  200eb6:	f3bf 8f6f 	isb	sy
__STATIC_INLINE void SCB_EnableICache (void)
{
  #if (__ICACHE_PRESENT == 1U)
    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
  200eba:	4c1b      	ldr	r4, [pc, #108]	; (200f28 <__core_init+0x78>)
  200ebc:	2200      	movs	r2, #0
  200ebe:	f8c4 2250 	str.w	r2, [r4, #592]	; 0x250
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
  200ec2:	6963      	ldr	r3, [r4, #20]
  200ec4:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  200ec8:	6163      	str	r3, [r4, #20]
  __ASM volatile ("dsb 0xF":::"memory");
  200eca:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  200ece:	f3bf 8f6f 	isb	sy
  #if (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = (0U << 1U) | 0U;          /* Level 1 data cache */
  200ed2:	f8c4 2084 	str.w	r2, [r4, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
  200ed6:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
  200eda:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
  200ede:	f643 7ee0 	movw	lr, #16352	; 0x3fe0
  200ee2:	f3c3 06c9 	ubfx	r6, r3, #3, #10

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
  200ee6:	f3c3 334e 	ubfx	r3, r3, #13, #15
  200eea:	07b7      	lsls	r7, r6, #30
  200eec:	015d      	lsls	r5, r3, #5
  200eee:	ea05 000e 	and.w	r0, r5, lr
  200ef2:	4639      	mov	r1, r7
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
  200ef4:	4632      	mov	r2, r6
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  200ef6:	ea41 0300 	orr.w	r3, r1, r0
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways--);
  200efa:	3a01      	subs	r2, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
  200efc:	f101 4140 	add.w	r1, r1, #3221225472	; 0xc0000000
  200f00:	f8c4 3260 	str.w	r3, [r4, #608]	; 0x260
      } while (ways--);
  200f04:	1c53      	adds	r3, r2, #1
  200f06:	d1f6      	bne.n	200ef6 <__core_init+0x46>
  200f08:	3d20      	subs	r5, #32
    } while(sets--);
  200f0a:	f115 0f20 	cmn.w	r5, #32
  200f0e:	d1ee      	bne.n	200eee <__core_init+0x3e>
  200f10:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
  200f14:	6963      	ldr	r3, [r4, #20]
  200f16:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  200f1a:	6163      	str	r3, [r4, #20]
  200f1c:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
  200f20:	f3bf 8f6f 	isb	sy
  200f24:	bdf0      	pop	{r4, r5, r6, r7, pc}
  200f26:	bf00      	nop
  200f28:	e000ed00 	.word	0xe000ed00
